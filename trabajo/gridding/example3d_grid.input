%----------------------------------------------%
% input parameters: for grid generation        %
%----------------------------------------------%
%
title{Cube grid}
%

dimension{3}   % spatial dimension in which the grid has to be generated

%---------------%
% output flags
%---------------%

print_level{1}	% how much information to print out: 0 Nothing | >0 Something

%---------------%
% files: output is in dir_grid/** where ** is nD for spatial dimension n.
%  	 the dir_grid/1D, dir_grid/2D ... should exist as
% 	 directories writeable by the user
% vtu files for plotting follow the same convention.
%---------------%

dir_grid{grids/}
dir_vtu{grids_vtu/}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
file_grid{unitCUBE_n17.haz}
file_vtu{unitCUBE_n17.vtu}

%---------------%
% coordinate systems: Each has coordinates of the origin o[0:dim-1]
%                     type (0=cartesian, 1=polar)
%
%---------------%

num_coordsystems{3} % number of coordinate systems

%% data for the coord systems: coord-system label, coords of the
%% origin, type. the labels should be integers, consequtive and start
%% from 0 the values of the above quantities are given as space/tab
%% separated values

data_coordsystems{0 0. 0.  0. 0
		  1 0. 0.  0. 1
		  2 -1. -1.  -1. 1}

%%%---------------%
%%% graph which describes the domain. The input are vertices and edges
%%% and d-1 dimensional faces. The graph has to be a union of
%%% polygons, of polyhedrons that are isomorphic to a d-dimensional
%%% cube.
%%%---------------%

num_vertices{8} %number of vertices

%---------------%

%%% coords: for every node 1:numvertices give coords (dim
%%% coords per node)
%%%
%%% If two points on an edge are in the same coordinate system,
%%% then all points on this edge are in polar coordinate system.
%%% if two points on an edge are in in different coordinate systems,
%%% then the points on the edge are on a straight
%%% line connecting the two vertices.
%---------------%


%%% vertex number (label) coords, coord_system
data_vertices{0 -1.  -1.   -1. 0
	      1 -1.  -1     1. 0
	      2 -1.   1.    -1. 0
	      3 -1.   1.   1.   0
	      4  1.  -1.   -1.  0
	      5  1.  -1.   1.	 0
	      6  1.   1.   -1. 	 0
	      7  1.   1.    1. 	 0}
%%%%%

%---------------%
% edges and number of divisions for every edge.
% opposite edges have the same number of divisions. if they do not,
% then the max number of divisions is taken.
%---------------%

num_edges{12} %

data_edges{0 1 3 %% edge: 1st vertex, 2nd vertex, number of divisions.
  	   4 0     1	      
	0 2	5 
	    1 3 	1 
	    1 5 	9
            3 7 		3
            7 5		3
  	    2 6     3	      
  	    4 6     1	      
  	    3 2     2	      
  	    7  6     7	      
            4 5	    1}	    

%%% ====================MACROELEMENTS=========================
num_macroelements{1}

%%% Numbering (ordering) of the vertices describing a macroelement:
%%% CHECK the README.

%%% MACROELEMENT: its 2^d vertices and a macroelement code.

data_macroelements{0 1 2 3 4 5 6 7  10
	       }

num_macrofaces{6}

% any face which needs a code (for example boundary faces: face
% number. If a face is not included here and is a boundary face then
% its code is set to Dirichlet (i.e. 1...16). Internal faces not found
% here have a code 0. Faces given here and not found in the
% macroelement list are ignored.

data_macrofaces{0 1 2 3 1
		0 4 1 5 3
		4 7 5 6 2
		2 6 3 7 4
		0 4 2 6 12
		1 5 7 3 17
		   }

%%%%%%%%%%%%%%AMR %%%%%%%%%%%%%%%%%%%%%%%%%%%%
num_refinements{1}

refinement_type{0}

err_stop_refinement{        -1.e-10        }



