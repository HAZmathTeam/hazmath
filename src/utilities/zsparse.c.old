/*KEEP HERE UNTIL m x m multiplications are working*/
/****IS THIS BELOW NEEDED???********************************/

void zicsr_mxm_symb_max(iCSRmat *A,iCSRmat *B,iCSRmat *C,	\
                       INT multmax)
{
  /* call the symbolic muultiplication. this is same as A*B, but we do
     not call A*B bc there is no multiplication here aij=bij=1 */
  icsr_mxm_symb(A,B,C);
  /**/
  INT np=C->row,nr=C->col,nnz=C->nnz; // INT nq=A->col;  
  INT i,j,k,jp,kp;
  INT *ia=A->IA, *ja=A->JA,*ib=B->IA, *jb=B->JA;
  INT *ic=C->IA, *jc=C->JA;
  /**/
  INT *c=(INT *)calloc(nnz,sizeof(INT));
  /**/
  INT *ix=(INT *)calloc(nr,sizeof(INT));
  for(i=0;i<np;i++){
    for(j = ic[i];j<ic[i+1];j++){
      ix[jc[j]] = 0;
    }
    for(jp=ia[i];jp<ia[i+1];jp++){
      j = ja[jp];
      //      a = an(jp) 
      for(kp=ib[j];kp<ib[j+1];kp++){
	k = jb[kp];
        ix[k]++; // +=a*bn(kp)
      }
    }
    for(j=ic[i];j<ic[i+1];j++){
      c[j] = ix[jc[j]];
    }
  }
  // skip everything that is not equal to multmax. this can be done in
  // the loop above but for now its OK
  nnz=0;
  for(i=0;i<np;i++){
    kp=ic[i];
    ic[i]=nnz;
    for(j = kp;j<ic[i+1];j++){
      if(c[j]!=multmax) continue;
      jc[nnz]=jc[j];
      //      fprintf(stdout,"\nYYYY: %d: %d<---%d",i,nnz,j);fflush(stdout);
      nnz++;
    }
  }
  ic[np]=nnz;
  free(ix);
  free(c);
  c=NULL;
  /**/
  C->JA=realloc(jc,nnz*sizeof(INT));
  C->nnz=nnz; // update the number of nonzeroes
  //  C->val=NULL; // it must be null already
  return;
}

void zzicsr_mxm_symb_max(iCSRmat *A,
                       iCSRmat *B,
                       iCSRmat *C,
                       INT multmax)
{
  INT i,j,k,l,count;

  INT *JD = (INT *)calloc(B->col,sizeof(INT));
  INT *entry_count = (INT *)calloc(B->col,sizeof(INT));

  C->row = A->row;
  C->col = B->col;
  C->val = NULL;
  C->JA  = NULL;
  C->IA  = (INT*)calloc(C->row+1,sizeof(INT));

  for (i=0;i<B->col;++i) {
    JD[i] = -1;
    entry_count[i] = 0;
  }

  // step 1: Find first the structure IA of C
  for(i=0;i<C->row;++i) {
    count=0;

    for (k=A->IA[i];k<A->IA[i+1];++k) {
      for (j=B->IA[A->JA[k]];j<B->IA[A->JA[k]+1];++j) {
        for (l=0;l<count;l++) {
          if (JD[l]==B->JA[j]) {
            entry_count[l] = entry_count[l]+1;
            break;
          }
        }

        if (l==count) {
          JD[count]=B->JA[j];
          entry_count[count] = 1;
          count++;
        }
      }


    }


    C->IA[i+1]=count;

    for (j=0;j<count;++j) {

      JD[j]=-1;

      if (entry_count[j] != multmax) C->IA[i+1] = C->IA[i+1]-1;

      entry_count[j] = 0;

    }


  }

  for (i=0;i<C->row;++i) C->IA[i+1]+=C->IA[i];


  // step 2: Find the structure JA of C
  INT countJD;

  C->JA=(INT*)calloc(C->IA[C->row],sizeof(INT));

  for (i=0;i<C->row;++i) {
    countJD=0;
    count=C->IA[i];

    for (k=A->IA[i];k<A->IA[i+1];++k) {
      for (j=B->IA[A->JA[k]];j<B->IA[A->JA[k]+1];++j) {
        for (l=0;l<countJD;l++) {
          if (JD[l]==B->JA[j]) {
            entry_count[l] = entry_count[l]+1;
            break;
          }
        }

        if (l==countJD) {
          //C->JA[count]=B->JA[j];
          JD[countJD]=B->JA[j];
          entry_count[countJD] = 1;
          //count++;
          countJD++;
        }
      }

    }

    for (j=0;j<countJD;++j) {
      if (entry_count[j] == multmax) {
        C->JA[count]=JD[j];
        count++;
      }
      JD[j]=-1;
      entry_count[j] = 0;
    }
  }

  // free
  free(JD);
  free(entry_count);

  C->nnz = C->IA[C->row]-C->IA[0];
}
/**/
void zicsr_mxm_symb(iCSRmat *A,
                   iCSRmat *B,
                   iCSRmat *C)
{
  INT i,j,k,l,count;

  INT *JD = (INT *)calloc(B->col,sizeof(INT));

  C->row = A->row;
  C->col = B->col;
  C->val = NULL;
  C->JA  = NULL;
  C->IA  = (INT*)calloc(C->row+1,sizeof(INT));

  for (i=0;i<B->col;++i) JD[i]=-1;

  // step 1: Find first the structure IA of C
  for(i=0;i<C->row;++i) {
    count=0;

    for (k=A->IA[i];k<A->IA[i+1];++k) {
      for (j=B->IA[A->JA[k]];j<B->IA[A->JA[k]+1];++j) {
        for (l=0;l<count;l++) {
          if (JD[l]==B->JA[j]) break;
        }

        if (l==count) {
          JD[count]=B->JA[j];
          count++;
        }
      }
    }
    C->IA[i+1]=count;
    for (j=0;j<count;++j) {
      JD[j]=-1;
    }
  }

  for (i=0;i<C->row;++i) C->IA[i+1]+=C->IA[i];

  // step 2: Find the structure JA of C
  INT countJD;

  C->JA=(INT*)calloc(C->IA[C->row],sizeof(INT));

  for (i=0;i<C->row;++i) {
    countJD=0;
    count=C->IA[i];
    for (k=A->IA[i];k<A->IA[i+1];++k) {
      for (j=B->IA[A->JA[k]];j<B->IA[A->JA[k]+1];++j) {
        for (l=0;l<countJD;l++) {
          if (JD[l]==B->JA[j]) break;
        }

        if (l==countJD) {
          C->JA[count]=B->JA[j];
          JD[countJD]=B->JA[j];
          count++;
          countJD++;
        }
      }
    }

    //for (j=0;j<countJD;++j) JD[j]=-1;
    memset(JD, -1, sizeof(INT)*countJD);
  }

  free(JD);

  C->nnz = C->IA[C->row]-C->IA[0];
}

/***********************************************************************************************/
/*!
   * \fn void icsr_mxm (iCSRmat *A, iCSRmat *B, iCSRmat *C)
   *
   * \brief Sparse matrix multiplication C=A*B (index starts with 0!!)
   *
   * \param A   Pointer to the iCSRmat matrix A
   * \param B   Pointer to the iCSRmat matrix B
   * \param C   Pointer to iCSRmat matrix equal to A*B
   *
   */
void icsr_mxm(iCSRmat *A,
              iCSRmat *B,
              iCSRmat *C)
{
  INT i,j,k,l,count;

  INT *JD = (INT *)calloc(B->col,sizeof(INT));

  C->row = A->row;
  C->col = B->col;
  C->val = NULL;
  C->JA  = NULL;
  C->IA  = (INT*)calloc(C->row+1,sizeof(INT));

  for (i=0;i<B->col;++i) JD[i]=-1;

  // step 1: Find first the structure IA of C
  for(i=0;i<C->row;++i) {
    count=0;

    for (k=A->IA[i];k<A->IA[i+1];++k) {
      for (j=B->IA[A->JA[k]];j<B->IA[A->JA[k]+1];++j) {
        for (l=0;l<count;l++) {
          if (JD[l]==B->JA[j]) break;
        }

        if (l==count) {
          JD[count]=B->JA[j];
          count++;
        }
      }
    }
    C->IA[i+1]=count;
    for (j=0;j<count;++j) {
      JD[j]=-1;
    }
  }

  for (i=0;i<C->row;++i) C->IA[i+1]+=C->IA[i];

  // step 2: Find the structure JA of C
  INT countJD;

  C->JA=(INT*)calloc(C->IA[C->row],sizeof(INT));

  for (i=0;i<C->row;++i) {
    countJD=0;
    count=C->IA[i];
    for (k=A->IA[i];k<A->IA[i+1];++k) {
      for (j=B->IA[A->JA[k]];j<B->IA[A->JA[k]+1];++j) {
        for (l=0;l<countJD;l++) {
          if (JD[l]==B->JA[j]) break;
        }

        if (l==countJD) {
          C->JA[count]=B->JA[j];
          JD[countJD]=B->JA[j];
          count++;
          countJD++;
        }
      }
    }

    //for (j=0;j<countJD;++j) JD[j]=-1;
    memset(JD, -1, sizeof(INT)*countJD);
  }

  free(JD);

  // step 3: Find the structure A of C
  C->val=(INT*)calloc(C->IA[C->row],sizeof(INT));

  for (i=0;i<C->row;++i) {
    for (j=C->IA[i];j<C->IA[i+1];++j) {
      C->val[j]=0;
      for (k=A->IA[i];k<A->IA[i+1];++k) {
        for (l=B->IA[A->JA[k]];l<B->IA[A->JA[k]+1];l++) {
          if (B->JA[l]==C->JA[j]) {
            C->val[j]+=A->val[k]*B->val[l];
          } // end if
        } // end for l
      } // end for k
    } // end for j
  }    // end for i

  C->nnz = C->IA[C->row]-C->IA[0];
}


