%----------------------------------------------%
% input parameters: for grid generation        %
%----------------------------------------------%
title{Square grid, or any other more or less descriptive title}
%
dimension{2}   % spatial dimension in which the grid has to be generated
%
print_level{1}	% how much information to print out: 0 Nothing | >0 Something

%---------------%
% files: output is in dir_grid/** where ** is nD for spatial dimension n.
%  	 the dir_grid/1D, dir_grid/2D ... should exist as
% 	 directories writeable by the user
% vtu files for plotting follow the same convention.
%---------------%

dir_grid{grids/}
dir_vtu{grids/}
%file_grid{unitLINE_n17.haz}
file_grid{unitSQ_n17.haz}
%file_grid{unitCUBE_n17.haz}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dir_vtu{grids_vtu/}
%file_vtu{unitLINE_n17.vtu}
file_vtu{unitSQ_n17.vtu}
%file_vtu{unitCUBE_n17.vtu}

%---------------%
% coordinate systems: Each has coordinates of the origin o[0:dim-1]
%                     type (0=cartesian, 1=polar)
%
%---------------%

num_coordsystems{3} % number of coordinate systems

%% data for the coord systems: coord-system label, coords of the
%% origin, type. the labels should be integers, consequtive and start
%% from 0 the values of the above quantities are given as space tab
%% separated values

data_coordsystems{0 0 0. 0.  
		  1 1 0. 0. 
		  2 1 -1. -1.}
%---------------%
% graph which describes the domain. The input are
% vertices and edges. The graph has to be a union of polygons,
% of polyhedrons that are isomorphic to an n-dimensional cube.
%---------------%

num_vertices{8} %number of vertices
%%% coords, type, origin for polar system: angles are in degrees
data_vertices{
	       0 1 2.    -90.    
	       1 1 2.   -180. 
	       2 1 1.   -90.
	       3 1 1.   -180.
	       4 1 2.    0.    
	       5 1 2.   90. 
	       6 1 1.   0.
	       7 1 1.   90.
	       	 }


%data_vertices{0 0 -1.   -1.   
%	      1 0   1.   -1.    
%	      2 0  -1.   1.    
%	      3 0   1.   1.    }
%
%---------------%
% edges and number of divisions for every edge.
% opposite edges have the same number of divisions. if they do not,
% then the max number of divisions is taken.
%---------------%

num_edges{9} %

%% edge: 1st vertex, 2nd vertex, number of divisions.
data_edges{
	   0 1	5
           0 2 		2
           1 3 		4
  	   2 3    	5	      
	   4 5		5
           4 6 		2
           5 7 		7
 	   1 5    	5
 	   0 4    	5
	   }


%%% ====================MACROELEMENTS=========================
num_macroelements{4}
%%% NUMBERING OF VERTICES DESCRIBING A MACROELEMENT: Check the README.

%%% macroelement number, vertices forming the macroelement, macroelement code.

data_macroelements{
0 1 2 3  3 
4 5 6 7  2 
5 1 7 3  2 
0 4 2 6  3 
}

num_macrofaces{1}

% any face which needs a code (for example boundary faces: face
% number. If a face is not included here and is a boundary face then
% its code is set to Dirichlet (i.e. 1...16). Internal faces not found
% here have a code 0. Faces given here and not found in the
% macroelement list are ignored.

data_macrofaces{0 1  1
		   }

%%%%%%%%%%%%%%AMR %%%%%%%%%%%%%%%%%%%%%%%%%%%%
num_refinements{1}

refinement_type{0}

err_stop_refinement{        -1.e-10        }
